// Code generated by peg. DO NOT EDIT.
package parser

// Code generated by peg ./function.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleFunction
	ruleArguments
	ruleConstValue
	ruleFieldReference
	ruleIntConstant
	ruleDoubleConstant
	ruleExponent
	ruleConstList
	ruleConstMap
	ruleEscapeLiteralChar
	ruleLiteral
	ruleIdentifier
	ruleListSeparator
	ruleLetter
	ruleLetterOrDigit
	ruleDigit
	ruleSkip
	ruleSpace
	ruleLBRK
	ruleRBRK
	ruleLWING
	ruleRWING
	ruleEQUAL
	ruleLPOINT
	ruleRPOINT
	ruleCOMMA
	ruleLPAR
	ruleRPAR
	ruleCOLON
	rulePegText
)

var rul3s = [...]string{
	"Unknown",
	"Function",
	"Arguments",
	"ConstValue",
	"FieldReference",
	"IntConstant",
	"DoubleConstant",
	"Exponent",
	"ConstList",
	"ConstMap",
	"EscapeLiteralChar",
	"Literal",
	"Identifier",
	"ListSeparator",
	"Letter",
	"LetterOrDigit",
	"Digit",
	"Skip",
	"Space",
	"LBRK",
	"RBRK",
	"LWING",
	"RWING",
	"EQUAL",
	"LPOINT",
	"RPOINT",
	"COMMA",
	"LPAR",
	"RPAR",
	"COLON",
	"PegText",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Function struct {
	Buffer string
	buffer []rune
	rules  [31]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Function) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Function) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Function
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Function) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Function) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Function) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*Function) error {
	return func(p *Function) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Function) error {
	return func(p *Function) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Function) Init(options ...func(*Function) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Function <- <('@' Identifier LPAR Arguments RPAR)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if buffer[position] != rune('@') {
					goto l0
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				if !_rules[ruleLPAR]() {
					goto l0
				}
				if !_rules[ruleArguments]() {
					goto l0
				}
				if !_rules[ruleRPAR]() {
					goto l0
				}
				add(ruleFunction, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Arguments <- <(ConstValue ListSeparator?)*> */
		func() bool {
			{
				position3 := position
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l5
					}
					{
						position6, tokenIndex6 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l6
						}
						goto l7
					l6:
						position, tokenIndex = position6, tokenIndex6
					}
				l7:
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				add(ruleArguments, position3)
			}
			return true
		},
		/* 2 ConstValue <- <(DoubleConstant / IntConstant / Literal / ConstList / ConstMap / FieldReference)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					if !_rules[ruleDoubleConstant]() {
						goto l11
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[ruleIntConstant]() {
						goto l12
					}
					goto l10
				l12:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[ruleLiteral]() {
						goto l13
					}
					goto l10
				l13:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[ruleConstList]() {
						goto l14
					}
					goto l10
				l14:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[ruleConstMap]() {
						goto l15
					}
					goto l10
				l15:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[ruleFieldReference]() {
						goto l8
					}
				}
			l10:
				add(ruleConstValue, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 3 FieldReference <- <('$' Identifier)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				if buffer[position] != rune('$') {
					goto l16
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l16
				}
				add(ruleFieldReference, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 IntConstant <- <(<(('0' 'x' ([0-9] / [A-Z] / [a-z])+) / ('0' 'o' Digit+) / (('+' / '-')? Digit+))> Skip)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20 := position
					{
						position21, tokenIndex21 := position, tokenIndex
						if buffer[position] != rune('0') {
							goto l22
						}
						position++
						if buffer[position] != rune('x') {
							goto l22
						}
						position++
						{
							position25, tokenIndex25 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l26
							}
							position++
							goto l25
						l26:
							position, tokenIndex = position25, tokenIndex25
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l27
							}
							position++
							goto l25
						l27:
							position, tokenIndex = position25, tokenIndex25
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l22
							}
							position++
						}
					l25:
					l23:
						{
							position24, tokenIndex24 := position, tokenIndex
							{
								position28, tokenIndex28 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l29
								}
								position++
								goto l28
							l29:
								position, tokenIndex = position28, tokenIndex28
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l30
								}
								position++
								goto l28
							l30:
								position, tokenIndex = position28, tokenIndex28
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l24
								}
								position++
							}
						l28:
							goto l23
						l24:
							position, tokenIndex = position24, tokenIndex24
						}
						goto l21
					l22:
						position, tokenIndex = position21, tokenIndex21
						if buffer[position] != rune('0') {
							goto l31
						}
						position++
						if buffer[position] != rune('o') {
							goto l31
						}
						position++
						if !_rules[ruleDigit]() {
							goto l31
						}
					l32:
						{
							position33, tokenIndex33 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l33
							}
							goto l32
						l33:
							position, tokenIndex = position33, tokenIndex33
						}
						goto l21
					l31:
						position, tokenIndex = position21, tokenIndex21
						{
							position34, tokenIndex34 := position, tokenIndex
							{
								position36, tokenIndex36 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l37
								}
								position++
								goto l36
							l37:
								position, tokenIndex = position36, tokenIndex36
								if buffer[position] != rune('-') {
									goto l34
								}
								position++
							}
						l36:
							goto l35
						l34:
							position, tokenIndex = position34, tokenIndex34
						}
					l35:
						if !_rules[ruleDigit]() {
							goto l18
						}
					l38:
						{
							position39, tokenIndex39 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l39
							}
							goto l38
						l39:
							position, tokenIndex = position39, tokenIndex39
						}
					}
				l21:
					add(rulePegText, position20)
				}
				if !_rules[ruleSkip]() {
					goto l18
				}
				add(ruleIntConstant, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 5 DoubleConstant <- <(<(('+' / '-')? ((Digit* '.' Digit+ Exponent?) / (Digit+ Exponent)))> Skip)> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				{
					position42 := position
					{
						position43, tokenIndex43 := position, tokenIndex
						{
							position45, tokenIndex45 := position, tokenIndex
							if buffer[position] != rune('+') {
								goto l46
							}
							position++
							goto l45
						l46:
							position, tokenIndex = position45, tokenIndex45
							if buffer[position] != rune('-') {
								goto l43
							}
							position++
						}
					l45:
						goto l44
					l43:
						position, tokenIndex = position43, tokenIndex43
					}
				l44:
					{
						position47, tokenIndex47 := position, tokenIndex
					l49:
						{
							position50, tokenIndex50 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l50
							}
							goto l49
						l50:
							position, tokenIndex = position50, tokenIndex50
						}
						if buffer[position] != rune('.') {
							goto l48
						}
						position++
						if !_rules[ruleDigit]() {
							goto l48
						}
					l51:
						{
							position52, tokenIndex52 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l52
							}
							goto l51
						l52:
							position, tokenIndex = position52, tokenIndex52
						}
						{
							position53, tokenIndex53 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l53
							}
							goto l54
						l53:
							position, tokenIndex = position53, tokenIndex53
						}
					l54:
						goto l47
					l48:
						position, tokenIndex = position47, tokenIndex47
						if !_rules[ruleDigit]() {
							goto l40
						}
					l55:
						{
							position56, tokenIndex56 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l56
							}
							goto l55
						l56:
							position, tokenIndex = position56, tokenIndex56
						}
						if !_rules[ruleExponent]() {
							goto l40
						}
					}
				l47:
					add(rulePegText, position42)
				}
				if !_rules[ruleSkip]() {
					goto l40
				}
				add(ruleDoubleConstant, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 6 Exponent <- <(('e' / 'E') IntConstant)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				{
					position59, tokenIndex59 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l60
					}
					position++
					goto l59
				l60:
					position, tokenIndex = position59, tokenIndex59
					if buffer[position] != rune('E') {
						goto l57
					}
					position++
				}
			l59:
				if !_rules[ruleIntConstant]() {
					goto l57
				}
				add(ruleExponent, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 7 ConstList <- <(LBRK (ConstValue ListSeparator?)* RBRK)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[ruleLBRK]() {
					goto l61
				}
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l64
					}
					{
						position65, tokenIndex65 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l65
						}
						goto l66
					l65:
						position, tokenIndex = position65, tokenIndex65
					}
				l66:
					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
				if !_rules[ruleRBRK]() {
					goto l61
				}
				add(ruleConstList, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 8 ConstMap <- <(LWING (ConstValue COLON ConstValue ListSeparator?)* RWING)> */
		func() bool {
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				if !_rules[ruleLWING]() {
					goto l67
				}
			l69:
				{
					position70, tokenIndex70 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l70
					}
					if !_rules[ruleCOLON]() {
						goto l70
					}
					if !_rules[ruleConstValue]() {
						goto l70
					}
					{
						position71, tokenIndex71 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l71
						}
						goto l72
					l71:
						position, tokenIndex = position71, tokenIndex71
					}
				l72:
					goto l69
				l70:
					position, tokenIndex = position70, tokenIndex70
				}
				if !_rules[ruleRWING]() {
					goto l67
				}
				add(ruleConstMap, position68)
			}
			return true
		l67:
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 9 EscapeLiteralChar <- <('\\' ('"' / '\''))> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				if buffer[position] != rune('\\') {
					goto l73
				}
				position++
				{
					position75, tokenIndex75 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l76
					}
					position++
					goto l75
				l76:
					position, tokenIndex = position75, tokenIndex75
					if buffer[position] != rune('\'') {
						goto l73
					}
					position++
				}
			l75:
				add(ruleEscapeLiteralChar, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 10 Literal <- <(('"' <(EscapeLiteralChar / (!'"' .))*> '"' Skip) / ('\'' <(EscapeLiteralChar / (!'\'' .))*> '\'' Skip))> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				{
					position79, tokenIndex79 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l80
					}
					position++
					{
						position81 := position
					l82:
						{
							position83, tokenIndex83 := position, tokenIndex
							{
								position84, tokenIndex84 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l85
								}
								goto l84
							l85:
								position, tokenIndex = position84, tokenIndex84
								{
									position86, tokenIndex86 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l86
									}
									position++
									goto l83
								l86:
									position, tokenIndex = position86, tokenIndex86
								}
								if !matchDot() {
									goto l83
								}
							}
						l84:
							goto l82
						l83:
							position, tokenIndex = position83, tokenIndex83
						}
						add(rulePegText, position81)
					}
					if buffer[position] != rune('"') {
						goto l80
					}
					position++
					if !_rules[ruleSkip]() {
						goto l80
					}
					goto l79
				l80:
					position, tokenIndex = position79, tokenIndex79
					if buffer[position] != rune('\'') {
						goto l77
					}
					position++
					{
						position87 := position
					l88:
						{
							position89, tokenIndex89 := position, tokenIndex
							{
								position90, tokenIndex90 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l91
								}
								goto l90
							l91:
								position, tokenIndex = position90, tokenIndex90
								{
									position92, tokenIndex92 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l92
									}
									position++
									goto l89
								l92:
									position, tokenIndex = position92, tokenIndex92
								}
								if !matchDot() {
									goto l89
								}
							}
						l90:
							goto l88
						l89:
							position, tokenIndex = position89, tokenIndex89
						}
						add(rulePegText, position87)
					}
					if buffer[position] != rune('\'') {
						goto l77
					}
					position++
					if !_rules[ruleSkip]() {
						goto l77
					}
				}
			l79:
				add(ruleLiteral, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 11 Identifier <- <(<(Letter (Letter / Digit / '.')*)> Skip)> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				{
					position95 := position
					if !_rules[ruleLetter]() {
						goto l93
					}
				l96:
					{
						position97, tokenIndex97 := position, tokenIndex
						{
							position98, tokenIndex98 := position, tokenIndex
							if !_rules[ruleLetter]() {
								goto l99
							}
							goto l98
						l99:
							position, tokenIndex = position98, tokenIndex98
							if !_rules[ruleDigit]() {
								goto l100
							}
							goto l98
						l100:
							position, tokenIndex = position98, tokenIndex98
							if buffer[position] != rune('.') {
								goto l97
							}
							position++
						}
					l98:
						goto l96
					l97:
						position, tokenIndex = position97, tokenIndex97
					}
					add(rulePegText, position95)
				}
				if !_rules[ruleSkip]() {
					goto l93
				}
				add(ruleIdentifier, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 12 ListSeparator <- <((',' / ';') Skip)> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				{
					position103, tokenIndex103 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l104
					}
					position++
					goto l103
				l104:
					position, tokenIndex = position103, tokenIndex103
					if buffer[position] != rune(';') {
						goto l101
					}
					position++
				}
			l103:
				if !_rules[ruleSkip]() {
					goto l101
				}
				add(ruleListSeparator, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 13 Letter <- <([A-Z] / [a-z] / '_')> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				{
					position107, tokenIndex107 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l108
					}
					position++
					goto l107
				l108:
					position, tokenIndex = position107, tokenIndex107
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l109
					}
					position++
					goto l107
				l109:
					position, tokenIndex = position107, tokenIndex107
					if buffer[position] != rune('_') {
						goto l105
					}
					position++
				}
			l107:
				add(ruleLetter, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 14 LetterOrDigit <- <([a-z] / [A-Z] / [0-9] / ('_' / '$'))> */
		nil,
		/* 15 Digit <- <[0-9]> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l111
				}
				position++
				add(ruleDigit, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 16 Skip <- <Space*> */
		func() bool {
			{
				position114 := position
			l115:
				{
					position116, tokenIndex116 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l116
					}
					goto l115
				l116:
					position, tokenIndex = position116, tokenIndex116
				}
				add(ruleSkip, position114)
			}
			return true
		},
		/* 17 Space <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position117, tokenIndex117 := position, tokenIndex
			{
				position118 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l122
					}
					position++
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					if buffer[position] != rune('\t') {
						goto l123
					}
					position++
					goto l121
				l123:
					position, tokenIndex = position121, tokenIndex121
					if buffer[position] != rune('\r') {
						goto l124
					}
					position++
					goto l121
				l124:
					position, tokenIndex = position121, tokenIndex121
					if buffer[position] != rune('\n') {
						goto l117
					}
					position++
				}
			l121:
			l119:
				{
					position120, tokenIndex120 := position, tokenIndex
					{
						position125, tokenIndex125 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l126
						}
						position++
						goto l125
					l126:
						position, tokenIndex = position125, tokenIndex125
						if buffer[position] != rune('\t') {
							goto l127
						}
						position++
						goto l125
					l127:
						position, tokenIndex = position125, tokenIndex125
						if buffer[position] != rune('\r') {
							goto l128
						}
						position++
						goto l125
					l128:
						position, tokenIndex = position125, tokenIndex125
						if buffer[position] != rune('\n') {
							goto l120
						}
						position++
					}
				l125:
					goto l119
				l120:
					position, tokenIndex = position120, tokenIndex120
				}
				add(ruleSpace, position118)
			}
			return true
		l117:
			position, tokenIndex = position117, tokenIndex117
			return false
		},
		/* 18 LBRK <- <('[' Skip)> */
		func() bool {
			position129, tokenIndex129 := position, tokenIndex
			{
				position130 := position
				if buffer[position] != rune('[') {
					goto l129
				}
				position++
				if !_rules[ruleSkip]() {
					goto l129
				}
				add(ruleLBRK, position130)
			}
			return true
		l129:
			position, tokenIndex = position129, tokenIndex129
			return false
		},
		/* 19 RBRK <- <(']' Skip)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune(']') {
					goto l131
				}
				position++
				if !_rules[ruleSkip]() {
					goto l131
				}
				add(ruleRBRK, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 20 LWING <- <('{' Skip)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if buffer[position] != rune('{') {
					goto l133
				}
				position++
				if !_rules[ruleSkip]() {
					goto l133
				}
				add(ruleLWING, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 21 RWING <- <('}' Skip)> */
		func() bool {
			position135, tokenIndex135 := position, tokenIndex
			{
				position136 := position
				if buffer[position] != rune('}') {
					goto l135
				}
				position++
				if !_rules[ruleSkip]() {
					goto l135
				}
				add(ruleRWING, position136)
			}
			return true
		l135:
			position, tokenIndex = position135, tokenIndex135
			return false
		},
		/* 22 EQUAL <- <('=' Skip)> */
		nil,
		/* 23 LPOINT <- <('<' Skip)> */
		nil,
		/* 24 RPOINT <- <('>' Skip)> */
		nil,
		/* 25 COMMA <- <(',' Skip)> */
		nil,
		/* 26 LPAR <- <('(' Skip)> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				if buffer[position] != rune('(') {
					goto l141
				}
				position++
				if !_rules[ruleSkip]() {
					goto l141
				}
				add(ruleLPAR, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 27 RPAR <- <(')' Skip)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if buffer[position] != rune(')') {
					goto l143
				}
				position++
				if !_rules[ruleSkip]() {
					goto l143
				}
				add(ruleRPAR, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 28 COLON <- <(':' Skip)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune(':') {
					goto l145
				}
				position++
				if !_rules[ruleSkip]() {
					goto l145
				}
				add(ruleCOLON, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		nil,
	}
	p.rules = _rules
	return nil
}
