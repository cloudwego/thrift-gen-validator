package parser

// Code generated by peg ./function.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleFunction
	ruleArguments
	ruleConstValue
	ruleFieldReference
	ruleIntConstant
	ruleDoubleConstant
	ruleExponent
	ruleConstList
	ruleConstMap
	ruleEscapeLiteralChar
	ruleLiteral
	ruleIdentifier
	ruleListSeparator
	ruleLetter
	ruleLetterOrDigit
	ruleDigit
	ruleSkip
	ruleSpace
	ruleLBRK
	ruleRBRK
	ruleLWING
	ruleRWING
	ruleEQUAL
	ruleLPOINT
	ruleRPOINT
	ruleCOMMA
	ruleLPAR
	ruleRPAR
	ruleCOLON
	rulePegText
)

var rul3s = [...]string{
	"Unknown",
	"Function",
	"Arguments",
	"ConstValue",
	"FieldReference",
	"IntConstant",
	"DoubleConstant",
	"Exponent",
	"ConstList",
	"ConstMap",
	"EscapeLiteralChar",
	"Literal",
	"Identifier",
	"ListSeparator",
	"Letter",
	"LetterOrDigit",
	"Digit",
	"Skip",
	"Space",
	"LBRK",
	"RBRK",
	"LWING",
	"RWING",
	"EQUAL",
	"LPOINT",
	"RPOINT",
	"COMMA",
	"LPAR",
	"RPAR",
	"COLON",
	"PegText",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Function struct {
	Buffer string
	buffer []rune
	rules  [31]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Function) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Function) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Function
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Function) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Function) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Function) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*Function) error {
	return func(p *Function) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Function) error {
	return func(p *Function) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Function) Init(options ...func(*Function) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Function <- <('@' Identifier LPAR Arguments RPAR)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if buffer[position] != rune('@') {
					goto l0
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				if !_rules[ruleLPAR]() {
					goto l0
				}
				if !_rules[ruleArguments]() {
					goto l0
				}
				if !_rules[ruleRPAR]() {
					goto l0
				}
				add(ruleFunction, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Arguments <- <((ConstValue / Function) ListSeparator?)*> */
		func() bool {
			{
				position3 := position
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					{
						position6, tokenIndex6 := position, tokenIndex
						if !_rules[ruleConstValue]() {
							goto l7
						}
						goto l6
					l7:
						position, tokenIndex = position6, tokenIndex6
						if !_rules[ruleFunction]() {
							goto l5
						}
					}
				l6:
					{
						position8, tokenIndex8 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l8
						}
						goto l9
					l8:
						position, tokenIndex = position8, tokenIndex8
					}
				l9:
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				add(ruleArguments, position3)
			}
			return true
		},
		/* 2 ConstValue <- <(DoubleConstant / IntConstant / Literal / ConstList / ConstMap / FieldReference)> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				{
					position12, tokenIndex12 := position, tokenIndex
					if !_rules[ruleDoubleConstant]() {
						goto l13
					}
					goto l12
				l13:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleIntConstant]() {
						goto l14
					}
					goto l12
				l14:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleLiteral]() {
						goto l15
					}
					goto l12
				l15:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleConstList]() {
						goto l16
					}
					goto l12
				l16:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleConstMap]() {
						goto l17
					}
					goto l12
				l17:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleFieldReference]() {
						goto l10
					}
				}
			l12:
				add(ruleConstValue, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 FieldReference <- <('$' Identifier)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				if buffer[position] != rune('$') {
					goto l18
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l18
				}
				add(ruleFieldReference, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 IntConstant <- <(<(('0' 'x' ([0-9] / [A-Z] / [a-z])+) / ('0' 'o' Digit+) / (('+' / '-')? Digit+))> Skip)> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position22 := position
					{
						position23, tokenIndex23 := position, tokenIndex
						if buffer[position] != rune('0') {
							goto l24
						}
						position++
						if buffer[position] != rune('x') {
							goto l24
						}
						position++
						{
							position27, tokenIndex27 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l28
							}
							position++
							goto l27
						l28:
							position, tokenIndex = position27, tokenIndex27
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l29
							}
							position++
							goto l27
						l29:
							position, tokenIndex = position27, tokenIndex27
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l24
							}
							position++
						}
					l27:
					l25:
						{
							position26, tokenIndex26 := position, tokenIndex
							{
								position30, tokenIndex30 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l31
								}
								position++
								goto l30
							l31:
								position, tokenIndex = position30, tokenIndex30
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l32
								}
								position++
								goto l30
							l32:
								position, tokenIndex = position30, tokenIndex30
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l26
								}
								position++
							}
						l30:
							goto l25
						l26:
							position, tokenIndex = position26, tokenIndex26
						}
						goto l23
					l24:
						position, tokenIndex = position23, tokenIndex23
						if buffer[position] != rune('0') {
							goto l33
						}
						position++
						if buffer[position] != rune('o') {
							goto l33
						}
						position++
						if !_rules[ruleDigit]() {
							goto l33
						}
					l34:
						{
							position35, tokenIndex35 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l35
							}
							goto l34
						l35:
							position, tokenIndex = position35, tokenIndex35
						}
						goto l23
					l33:
						position, tokenIndex = position23, tokenIndex23
						{
							position36, tokenIndex36 := position, tokenIndex
							{
								position38, tokenIndex38 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l39
								}
								position++
								goto l38
							l39:
								position, tokenIndex = position38, tokenIndex38
								if buffer[position] != rune('-') {
									goto l36
								}
								position++
							}
						l38:
							goto l37
						l36:
							position, tokenIndex = position36, tokenIndex36
						}
					l37:
						if !_rules[ruleDigit]() {
							goto l20
						}
					l40:
						{
							position41, tokenIndex41 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l41
							}
							goto l40
						l41:
							position, tokenIndex = position41, tokenIndex41
						}
					}
				l23:
					add(rulePegText, position22)
				}
				if !_rules[ruleSkip]() {
					goto l20
				}
				add(ruleIntConstant, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 5 DoubleConstant <- <(<(('+' / '-')? ((Digit* '.' Digit+ Exponent?) / (Digit+ Exponent)))> Skip)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44 := position
					{
						position45, tokenIndex45 := position, tokenIndex
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune('+') {
								goto l48
							}
							position++
							goto l47
						l48:
							position, tokenIndex = position47, tokenIndex47
							if buffer[position] != rune('-') {
								goto l45
							}
							position++
						}
					l47:
						goto l46
					l45:
						position, tokenIndex = position45, tokenIndex45
					}
				l46:
					{
						position49, tokenIndex49 := position, tokenIndex
					l51:
						{
							position52, tokenIndex52 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l52
							}
							goto l51
						l52:
							position, tokenIndex = position52, tokenIndex52
						}
						if buffer[position] != rune('.') {
							goto l50
						}
						position++
						if !_rules[ruleDigit]() {
							goto l50
						}
					l53:
						{
							position54, tokenIndex54 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l54
							}
							goto l53
						l54:
							position, tokenIndex = position54, tokenIndex54
						}
						{
							position55, tokenIndex55 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l55
							}
							goto l56
						l55:
							position, tokenIndex = position55, tokenIndex55
						}
					l56:
						goto l49
					l50:
						position, tokenIndex = position49, tokenIndex49
						if !_rules[ruleDigit]() {
							goto l42
						}
					l57:
						{
							position58, tokenIndex58 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l58
							}
							goto l57
						l58:
							position, tokenIndex = position58, tokenIndex58
						}
						if !_rules[ruleExponent]() {
							goto l42
						}
					}
				l49:
					add(rulePegText, position44)
				}
				if !_rules[ruleSkip]() {
					goto l42
				}
				add(ruleDoubleConstant, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 6 Exponent <- <(('e' / 'E') IntConstant)> */
		func() bool {
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				{
					position61, tokenIndex61 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l62
					}
					position++
					goto l61
				l62:
					position, tokenIndex = position61, tokenIndex61
					if buffer[position] != rune('E') {
						goto l59
					}
					position++
				}
			l61:
				if !_rules[ruleIntConstant]() {
					goto l59
				}
				add(ruleExponent, position60)
			}
			return true
		l59:
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 7 ConstList <- <(LBRK (ConstValue ListSeparator?)* RBRK)> */
		func() bool {
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				if !_rules[ruleLBRK]() {
					goto l63
				}
			l65:
				{
					position66, tokenIndex66 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l66
					}
					{
						position67, tokenIndex67 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l67
						}
						goto l68
					l67:
						position, tokenIndex = position67, tokenIndex67
					}
				l68:
					goto l65
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
				if !_rules[ruleRBRK]() {
					goto l63
				}
				add(ruleConstList, position64)
			}
			return true
		l63:
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 8 ConstMap <- <(LWING (ConstValue COLON ConstValue ListSeparator?)* RWING)> */
		func() bool {
			position69, tokenIndex69 := position, tokenIndex
			{
				position70 := position
				if !_rules[ruleLWING]() {
					goto l69
				}
			l71:
				{
					position72, tokenIndex72 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l72
					}
					if !_rules[ruleCOLON]() {
						goto l72
					}
					if !_rules[ruleConstValue]() {
						goto l72
					}
					{
						position73, tokenIndex73 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l73
						}
						goto l74
					l73:
						position, tokenIndex = position73, tokenIndex73
					}
				l74:
					goto l71
				l72:
					position, tokenIndex = position72, tokenIndex72
				}
				if !_rules[ruleRWING]() {
					goto l69
				}
				add(ruleConstMap, position70)
			}
			return true
		l69:
			position, tokenIndex = position69, tokenIndex69
			return false
		},
		/* 9 EscapeLiteralChar <- <('\\' ('"' / '\''))> */
		func() bool {
			position75, tokenIndex75 := position, tokenIndex
			{
				position76 := position
				if buffer[position] != rune('\\') {
					goto l75
				}
				position++
				{
					position77, tokenIndex77 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l78
					}
					position++
					goto l77
				l78:
					position, tokenIndex = position77, tokenIndex77
					if buffer[position] != rune('\'') {
						goto l75
					}
					position++
				}
			l77:
				add(ruleEscapeLiteralChar, position76)
			}
			return true
		l75:
			position, tokenIndex = position75, tokenIndex75
			return false
		},
		/* 10 Literal <- <(('"' <(EscapeLiteralChar / (!'"' .))*> '"' Skip) / ('\'' <(EscapeLiteralChar / (!'\'' .))*> '\'' Skip))> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l82
					}
					position++
					{
						position83 := position
					l84:
						{
							position85, tokenIndex85 := position, tokenIndex
							{
								position86, tokenIndex86 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l87
								}
								goto l86
							l87:
								position, tokenIndex = position86, tokenIndex86
								{
									position88, tokenIndex88 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l88
									}
									position++
									goto l85
								l88:
									position, tokenIndex = position88, tokenIndex88
								}
								if !matchDot() {
									goto l85
								}
							}
						l86:
							goto l84
						l85:
							position, tokenIndex = position85, tokenIndex85
						}
						add(rulePegText, position83)
					}
					if buffer[position] != rune('"') {
						goto l82
					}
					position++
					if !_rules[ruleSkip]() {
						goto l82
					}
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('\'') {
						goto l79
					}
					position++
					{
						position89 := position
					l90:
						{
							position91, tokenIndex91 := position, tokenIndex
							{
								position92, tokenIndex92 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l93
								}
								goto l92
							l93:
								position, tokenIndex = position92, tokenIndex92
								{
									position94, tokenIndex94 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l94
									}
									position++
									goto l91
								l94:
									position, tokenIndex = position94, tokenIndex94
								}
								if !matchDot() {
									goto l91
								}
							}
						l92:
							goto l90
						l91:
							position, tokenIndex = position91, tokenIndex91
						}
						add(rulePegText, position89)
					}
					if buffer[position] != rune('\'') {
						goto l79
					}
					position++
					if !_rules[ruleSkip]() {
						goto l79
					}
				}
			l81:
				add(ruleLiteral, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 11 Identifier <- <(<(Letter (Letter / Digit / '.')*)> Skip)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97 := position
					if !_rules[ruleLetter]() {
						goto l95
					}
				l98:
					{
						position99, tokenIndex99 := position, tokenIndex
						{
							position100, tokenIndex100 := position, tokenIndex
							if !_rules[ruleLetter]() {
								goto l101
							}
							goto l100
						l101:
							position, tokenIndex = position100, tokenIndex100
							if !_rules[ruleDigit]() {
								goto l102
							}
							goto l100
						l102:
							position, tokenIndex = position100, tokenIndex100
							if buffer[position] != rune('.') {
								goto l99
							}
							position++
						}
					l100:
						goto l98
					l99:
						position, tokenIndex = position99, tokenIndex99
					}
					add(rulePegText, position97)
				}
				if !_rules[ruleSkip]() {
					goto l95
				}
				add(ruleIdentifier, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 12 ListSeparator <- <((',' / ';') Skip)> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				{
					position105, tokenIndex105 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l106
					}
					position++
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if buffer[position] != rune(';') {
						goto l103
					}
					position++
				}
			l105:
				if !_rules[ruleSkip]() {
					goto l103
				}
				add(ruleListSeparator, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 13 Letter <- <([A-Z] / [a-z] / '_')> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l110
					}
					position++
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l111
					}
					position++
					goto l109
				l111:
					position, tokenIndex = position109, tokenIndex109
					if buffer[position] != rune('_') {
						goto l107
					}
					position++
				}
			l109:
				add(ruleLetter, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 14 LetterOrDigit <- <([a-z] / [A-Z] / [0-9] / ('_' / '$'))> */
		nil,
		/* 15 Digit <- <[0-9]> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l113
				}
				position++
				add(ruleDigit, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 16 Skip <- <Space*> */
		func() bool {
			{
				position116 := position
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(ruleSkip, position116)
			}
			return true
		},
		/* 17 Space <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position123, tokenIndex123 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l124
					}
					position++
					goto l123
				l124:
					position, tokenIndex = position123, tokenIndex123
					if buffer[position] != rune('\t') {
						goto l125
					}
					position++
					goto l123
				l125:
					position, tokenIndex = position123, tokenIndex123
					if buffer[position] != rune('\r') {
						goto l126
					}
					position++
					goto l123
				l126:
					position, tokenIndex = position123, tokenIndex123
					if buffer[position] != rune('\n') {
						goto l119
					}
					position++
				}
			l123:
			l121:
				{
					position122, tokenIndex122 := position, tokenIndex
					{
						position127, tokenIndex127 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l128
						}
						position++
						goto l127
					l128:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('\t') {
							goto l129
						}
						position++
						goto l127
					l129:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('\r') {
							goto l130
						}
						position++
						goto l127
					l130:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('\n') {
							goto l122
						}
						position++
					}
				l127:
					goto l121
				l122:
					position, tokenIndex = position122, tokenIndex122
				}
				add(ruleSpace, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 18 LBRK <- <('[' Skip)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune('[') {
					goto l131
				}
				position++
				if !_rules[ruleSkip]() {
					goto l131
				}
				add(ruleLBRK, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 19 RBRK <- <(']' Skip)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if buffer[position] != rune(']') {
					goto l133
				}
				position++
				if !_rules[ruleSkip]() {
					goto l133
				}
				add(ruleRBRK, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 20 LWING <- <('{' Skip)> */
		func() bool {
			position135, tokenIndex135 := position, tokenIndex
			{
				position136 := position
				if buffer[position] != rune('{') {
					goto l135
				}
				position++
				if !_rules[ruleSkip]() {
					goto l135
				}
				add(ruleLWING, position136)
			}
			return true
		l135:
			position, tokenIndex = position135, tokenIndex135
			return false
		},
		/* 21 RWING <- <('}' Skip)> */
		func() bool {
			position137, tokenIndex137 := position, tokenIndex
			{
				position138 := position
				if buffer[position] != rune('}') {
					goto l137
				}
				position++
				if !_rules[ruleSkip]() {
					goto l137
				}
				add(ruleRWING, position138)
			}
			return true
		l137:
			position, tokenIndex = position137, tokenIndex137
			return false
		},
		/* 22 EQUAL <- <('=' Skip)> */
		nil,
		/* 23 LPOINT <- <('<' Skip)> */
		nil,
		/* 24 RPOINT <- <('>' Skip)> */
		nil,
		/* 25 COMMA <- <(',' Skip)> */
		nil,
		/* 26 LPAR <- <('(' Skip)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if buffer[position] != rune('(') {
					goto l143
				}
				position++
				if !_rules[ruleSkip]() {
					goto l143
				}
				add(ruleLPAR, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 27 RPAR <- <(')' Skip)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune(')') {
					goto l145
				}
				position++
				if !_rules[ruleSkip]() {
					goto l145
				}
				add(ruleRPAR, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 28 COLON <- <(':' Skip)> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				if buffer[position] != rune(':') {
					goto l147
				}
				position++
				if !_rules[ruleSkip]() {
					goto l147
				}
				add(ruleCOLON, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		nil,
	}
	p.rules = _rules
	return nil
}
